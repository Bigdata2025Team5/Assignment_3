CREATE OR REPLACE PROCEDURE CO2_DB.UPDATE_CO2.UPDATE_CO2_METRICS_SP()
RETURNS STRING
LANGUAGE SQL
AS
$$
DECLARE
  new_records INTEGER;
  processed_count INTEGER;
  result_status STRING;
BEGIN
  -- Step 1: Create a temporary stream to capture changes if it doesn't exist already
  CREATE STREAM IF NOT EXISTS CO2_DB.HARMONIZED_CO2.CO2_EMISSIONS_STREAM 
    ON TABLE CO2_DB.HARMONIZED_CO2.CO2_EMISSIONS_HARMONIZED;
  -- Step 2: Count how many new records we need to process
  SELECT COUNT(*) INTO :new_records FROM CO2_DB.HARMONIZED_CO2.CO2_EMISSIONS_STREAM;
  -- Step 3: Insert new daily metrics into analytics table
  INSERT INTO CO2_DB.ANALYTICS_CO2.DAILY_CO2_METRICS (
    DATE,
    CO2_PPM,
    DAILY_CHANGE_PPM,
    DAILY_CHANGE_PERCENT,
    SEASONAL_VARIATION,
    TREND_ANALYSIS,
    LAST_UPDATED
  )
  SELECT 
    s.DATE,
    s.CO2_PPM,
    s.CO2_PPM - LAG(s.CO2_PPM) OVER (ORDER BY s.DATE) AS DAILY_CHANGE_PPM,
    ((s.CO2_PPM - LAG(s.CO2_PPM) OVER (ORDER BY s.DATE)) / NULLIF(LAG(s.CO2_PPM) OVER (ORDER BY s.DATE), 0)) * 100 AS DAILY_CHANGE_PERCENT,
    CO2_DB.HARMONIZED_CO2.CALCULATE_SEASONAL_VARIATION(s.DATE, s.CO2_PPM) AS SEASONAL_VARIATION,
    CASE 
      WHEN s.CO2_PPM > 420 THEN 'CRITICAL'
      WHEN s.CO2_PPM > 400 THEN 'HIGH'
      ELSE 'NORMAL'
    END AS TREND_ANALYSIS,
    CURRENT_TIMESTAMP() AS LAST_UPDATED
  FROM CO2_DB.HARMONIZED_CO2.CO2_EMISSIONS_STREAM s
  WHERE s.METADATA$ACTION = 'INSERT';
  SET processed_count = SQLROWCOUNT;
  -- Step 4: Update weekly aggregations
  MERGE INTO CO2_DB.ANALYTICS_CO2.WEEKLY_CO2_METRICS w
  USING (
    SELECT 
      DATE_TRUNC('WEEK', DATE) AS WEEK_START,
      AVG(CO2_PPM) AS AVG_CO2_PPM,
      MIN(CO2_PPM) AS MIN_CO2_PPM,
      MAX(CO2_PPM) AS MAX_CO2_PPM,
      AVG(DAILY_CHANGE_PERCENT) AS AVG_DAILY_CHANGE_PERCENT,
      VARIANCE(DAILY_CHANGE_PERCENT) AS VOLATILITY,
      COUNT(*) AS DAYS_WITH_DATA
    FROM CO2_DB.ANALYTICS_CO2.DAILY_CO2_METRICS
    WHERE DATE >= DATE_TRUNC('WEEK', CURRENT_DATE() - INTERVAL '4 WEEKS')
    GROUP BY DATE_TRUNC('WEEK', DATE)
  ) d ON w.WEEK_START = d.WEEK_START
  WHEN MATCHED THEN
    UPDATE SET 
      w.AVG_CO2_PPM = d.AVG_CO2_PPM,
      w.MIN_CO2_PPM = d.MIN_CO2_PPM,
      w.MAX_CO2_PPM = d.MAX_CO2_PPM,
      w.AVG_DAILY_CHANGE_PERCENT = d.AVG_DAILY_CHANGE_PERCENT,
      w.VOLATILITY = d.VOLATILITY,
      w.DAYS_WITH_DATA = d.DAYS_WITH_DATA,
      w.LAST_UPDATED = CURRENT_TIMESTAMP()
  WHEN NOT MATCHED THEN
    INSERT (
      WEEK_START, 
      AVG_CO2_PPM, 
      MIN_CO2_PPM, 
      MAX_CO2_PPM, 
      AVG_DAILY_CHANGE_PERCENT, 
      VOLATILITY, 
      DAYS_WITH_DATA, 
      LAST_UPDATED
    )
    VALUES (
      d.WEEK_START, 
      d.AVG_CO2_PPM, 
      d.MIN_CO2_PPM, 
      d.MAX_CO2_PPM, 
      d.AVG_DAILY_CHANGE_PERCENT, 
      d.VOLATILITY, 
      d.DAYS_WITH_DATA, 
      CURRENT_TIMESTAMP()
    );
  -- Step 5: Consume the stream to mark data as processed
  BEGIN
    -- Create a temporary table from the stream (which consumes the stream)
    CREATE OR REPLACE TEMPORARY TABLE CO2_DB.HARMONIZED_CO2.TEMP_CONSUMED AS
    SELECT * FROM CO2_DB.HARMONIZED_CO2.CO2_EMISSIONS_STREAM;
    -- Cleanup
    DROP TABLE IF EXISTS CO2_DB.HARMONIZED_CO2.TEMP_CONSUMED;
  END;
  -- Step 6: Return status
  SELECT 
    'Procedure executed successfully. Processed ' || 
    processed_count || 
    ' new records out of ' || 
    new_records || 
    ' changes detected.'
  INTO result_status;
  RETURN result_status;
END;
$$;
